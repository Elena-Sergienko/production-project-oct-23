// Стримы

/**
 * Тема 
 * /модуль.урок/стрим, время)/
 * 
 * описание
 */


/**
 * buildWebpackConfig.ts
 * /Стрим №1 18:15/
 * 
 * Этот файл хорошо  структурирован (часто на проектах этот файл может занимать около 1000 строк - плохо читаемы)
 * Здесь же действуют принцыпы декомпозции, разделения ответственности  
 * SOLID design principles,
 * KISS design principle, 
 * DRY principle
 * 
 * так, мы это декомпозировали и типизировали 
 * 
 * Как можно узнать какие типы использовать здесь? Автокомплит может помочь 
 */


/**
 * Plagins
 * /Модуль 1/
 *  HtmlWebpackPlugin - позволяет создавать Html файлик и прокидивать в него скрипты
 *  ProgressPlugin - чтобы отображать прогресс загрузки 
 */


/**
 * Lazy
 * /Стрим №1/
 * Кандидаты на выделение в отдельные чанки (и не включать в общий бандл)
 * Страницы, 
 * Модалки, шторки, тултипы
 * Блоки которые не попадают во вью порт 
 * Лэйзи использовать аккуратно - потому что если будет много чанков, то это ухудшит первоманс 
 * Значит: делаем точечно только в тех местах где это нужно 
 */


/**
 * eslint prettier разница
 * /Стрим 1/
 * Нужны оба поскольку делают разные вещи
 * eslint - статический анализ  кода на соответствие правилам 
 * prettier - форматирование (красота)
 */


/**
 * Различие между react contecst или условный стор store 
 * /Стрим-1 48:52/
 *
 * store - это обычно по большей части бизнес логика, мы храним там все
 * чтобы пропсами не прокидывать 
 * какая-то валидация, асинк фанки, все выносим туда, если это redux
 * А для контекста мы можем использовать веб сокет соединение, темы, какую-то библиотеку интернационализации можем сделать
 * т.е. контекст - это нативная реактовская штука в которую можем добавить все что угодно
 * store - это уже имплементация под наше приложение какой-то бизнес логики
 */


/**
 * eject 
 * /Стрим-1 49:50/
 * 
 * Разбор create react app - webpack 
 */


/**
 * В каких случаях создаем type а в каких interface  
 * /Стрим-1 52:43/
 * (упоминается несколько раз в этом стриме)
 * Принципиальной разницы нет, за исключением того что с типами мы можем делать юнионы
 * type Union = 'asc' | 'desc'
 * type Union = 'asc' & 'desc'
 * 
 * функции чуть удобнее объявлять
 * type Function = () => void;
 * 
 * картеж, где первый элемент например число, а второй строка
 * type Array = [string, number]
 * 
 * Интерфейсы же обычно просто для описания какай-то структуры объекта
 * interface Union {
 * username: string;
 * age: number;
 * }
 */


/**
 * От enum лучше отходить
 * /Стрим-1 54:10/ 
 * (еще об этом ранее в этом стриме)
 * я бы сделал юнион
 * type Theme = 'dark' | 'light';
 */


/**
 * UseMemo
 * /Стрим-1 54:40/ 
 * В чем преимущество изпользовать UseMemo для мемоизации 
 * За пределы компонента мы можем выносить массивы тогда когда они статичны
 * Если он динамически формируется, то его приходится в компоненте мемоизировать ч
 * чтобы он от рендера к рендеру он не обновлялся, чтобы ссылка сохранялась 
 * Желательно посмотреть далее - хорошее объяснение со ссылками на память и ререндером
 */

/**
 * Что лучше css in js (styled components) bkb css modules?
 * /Стрим-1  1:00:10/ 
 * styled components - да удобно, но есть важный минус - в runtime это имеет не нулевую ценность
 *  и приложение будет работать медленнее на 10-20%
 * Сейчас есть решения css in js которые билдятся, они поинтересней, но также влияют на скорость сборки
 * css modules - изоляция стилей из коробки 
 * сейчас прихожу к тому что препроцессоры less saas они не нужны поскольку могут увеличивать время сборки
 */

/**
 * Какие основные преимущества кастомной настройки webpack перед create react app
 * /Стрим-1  1:03:55/ 
 * /Стрим-1  1:09:25/ 
 * 1. Настраиваем все под себя - у нас нет лишнего
 * 2. Удобство в использовании 
 * 3. Рано или поздно в create react app прийдется сделать eject 
 * и потом в этой куче общего хлама прийдется наводить порядок
 * соответственно потратится еще больше времени чем напишем свой вебпак конфиг сначала
 * create react app - больше для учебный проектов или очень маленьких и быстрых где нужно быстро что-то слепить
 */

/**
 * Почему хелперы и хуки ты используешь function с названием а не стрелочную анонимную функцию?
 * /Стрим-1  1:07:40/ 
 *  Принципиальной разницы нет, однако function с названием лучше потому что 
 * 1. при дебаге в стак трейсе более понятные сообщения чем с анонимными функциями
 * 2. если вы мемоизируете компонент и передаете стрелочную функцию а не именованную
 * то в дебагере будет помечаться как anonimus - сложно в дереве компонентов дебаг делать
 */

/**
 * Импорты со звездочкой лучше никогда не делать 
 * /Стрим-1  1:10:15/ 
 * import * as против именованных импортов import { set }
 * Потому при *  три шейкинг ломается 
 */

/**
 * Дизайн система 
 * /Стрим-1  1:12:47/ 
 * у нас все кейсы, отступы, отображения все это будет покрывать наш ui-kit
 */

/**
 * Подробнее как webpack находит нужный HTML и кладет туда входной файл js и ts
 * /Стрим-1  1:28:16 
 */

/**
 * для иконак лучше всего использовать svg
 * /Стрим-1  1:33:00
 */

/**
 * intersection observer + react lasy - хорошо использовать когда нужно подгрузить то что во вью порт попало
 * /Стрим-1  1:36:00
 */



